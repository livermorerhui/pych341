# 解决 CH341 通过 pych341 控制 AD9833 的通信问题（L）

踩了太多坑了，快要搞死我，终于将控制代码写好。
- 能准确地输出特定频率的波形
  - 直接用pych341，虽然能控制CH341，但它的SPI的通讯与AD9833的不完全一致，导致AD9833接收到指令与数据手册的不一致
  
我写了两个文件：main_program.py和ch341_spi.py。这两个结合使用，通过 CH341的SPI发送的指令 和 AD9833的数据手册的一致
- ch341_spi.py：创建软件模拟 SPI 库，规范通讯，做到与 AD9833要求的一致
  - 因为 pych341 库并没有提供修改 SPI 模式的接口，其底层 CH341 芯片的硬件 SPI 很可能固定在 Mode 0 或 Mode 3，导致 AD9833 接收到的所有数据都是错误的，因此无法解析正确的频率和波形命令
  - 既然 pych341 的硬件 SPI 功能无法配置模式，我决定绕过它，利用其 GPIO 功能在软件层面完全模拟出 SPI_MODE2 的时序，这样就能解决数据接收错误的问题。
- main_program.py：交互式界面，可设定频率和波形
  - 包含经过完全重构的 AD9833 控制类和功能完善的交互式界面。它通过 ch341_spi.py 来确保与 AD9833 的通信完全符合数据手册要求。
---

好的，以下是我和Gemini讨论、分析和最终解决方案的完整技术备忘录，以便需要用的这份代码的人能全面了解整个问题的解决过程。

---

### **技术备忘录：关于使用 CH341 和 `pych341` 库精确控制 AD9833 的最终总结报告**

#### **1. 问题背景**

在项目开发初期，我们尝试使用 Python 的 `pych341` 库 配合 CH341 USB 转换器来控制 AD9833 波形发生器。然而，我们发现无法准确生成设定的频率和波形。作为参照，使用 Arduino 平台的 `md_ad9833` 库 则可以完美驱动同一硬件模块，这表明 AD9833 模块本身工作正常，问题出在 CH341 的控制链路上。

#### **2. 根本原因分析：硬件 SPI 模式不匹配**

为了定位问题，我们对 `md_ad9833` 库和 `pych341` 库进行了深入对比，并参照了 CH341 的官方数据手册 (`CH341DS2.PDF`)。

我们的核心发现是：**CH341 芯片的硬件 SPI 功能与 AD9833 芯片的通信要求存在根本性的协议不兼容**。

1.  **AD9833 的要求**：AD9833 数据手册规定，其 SPI 接口工作在 **SPI Mode 2** 模式下，即时钟极性(CPOL)=1（空闲时为高电平），时钟相位(CPHA)=0（在时钟的第一个边沿，即下降沿采样数据）。`md_ad9833` 库的硬件 SPI 实现也明确配置了 `SPI_MODE2`。

2.  **CH341 的局限性**：`CH341DS2.PDF` 数据手册在第 7 页明确描述了 `CH341StreamSPI4` 函数的时序：“DCK时钟输出,默认为低,DOUT 在时钟上升沿之前输出...”。这清晰地表明 CH341 的硬件 SPI 固定工作在 **SPI Mode 0** (CPOL=0, CPHA=0)。此外，手册中的 `CH341SetStream` 函数也未提供任何可以修改 SPI CPOL/CPHA 模式的配置位。

**结论**：由于 `pych341` 库依赖的 CH341 硬件 SPI 无法被配置为 Mode 2，导致 AD9833 在错误的时钟边沿采样数据，从而收到了完全错误的信息。这是导致波形和频率不准确的根本原因。

#### **3. 解决方案的演进与最终实现**

##### **3.1 尝试一：手动控制片选（CS）**
我们最初怀疑是 `pych341` 库的自动片选功能时序不当。通过改用 GPIO (`io_write`) 手动控制 CS 引脚，我们确实观察到 AD9833 对指令产生了响应（波形发生变化），但这并未解决数据错误的问题，从而证实了问题在于更底层的 SPI 模式。

##### **3.2 最终方案：软件模拟 SPI (Bit-Banging)**
既然硬件 SPI 无法满足要求，我们决定完全绕过它。我们利用 `pych341` 的底层 GPIO 功能，在 Python 层面**手动地、逐位地**模拟出精准的 `SPI_MODE2` 时序。

为此，我们开发了一个独立的辅助库 `ch341_spi.py`，其中包含一个 `SoftwareSPI` 类。该类的核心优势是：
* **完全可配置**：在实例化时，可以明确指定 `mode=SPI_MODE.MODE2`。
* **时序精准**：通过代码精确控制 SCK、MOSI 和 CS 引脚的电平跳变，完美复刻了 `SPI_MODE2` 的通信协议。
* **封装良好**：将复杂的位操作封装在 `transfer16` 方法中，对上层应用透明。

##### **3.3 上层逻辑完善**
在解决了底层的 SPI 通信问题后，我们还对 `AD9833` 控制类本身进行了优化，使其更加健壮：
* **修正状态管理**：重构了 `set_mode` 函数，确保在切换波形模式（特别是切换到 `OFF` 模式）时，能够正确清除旧模式的残留配置位，解决了“无法变为直线”的问题。
* **提升用户体验**：为交互式控制界面增加了波形名称的缩写，如 `sin`, `sq1` 等，提高了操作效率。

#### **4. 最终结论**

通过对 CH341 数据手册的研读和多轮实验，我们确认：**`pych341` 库无法直接通过其硬件 SPI 功能准确控制 AD9833 的根本原因，是 CH341 芯片自身的硬件限制**。

我们最终采用的 **软件模拟 SPI 方案** 是解决此问题的**最优工程实践**。它虽然在理论速度上低于硬件 SPI，但对于 AD9833 这种配置型设备而言绰绰有余，并从根本上保证了通信的**正确性**和**可靠性**。

目前，基于 `ch341_spi.py` 辅助库和最终版的 `AD9833` 控制类，我们已经实现了对 AD9833 的精确控制，功能已与参照的 `md_ad9833` 库对齐。此问题已圆满解决，可基于当前代码继续推进项目。

---

Ps:以后涉及硬件的开发，一定要仔细研究官方的数据手册。这样应该能缩短试错的时间。

---

# PyCh341

*注意：本库尚在开发中，API可能频繁变化*

CH341 是一个 USB 总线的转接芯片，通过 USB 总线提供异步串口、打印口、并口以及常用的 2 线和 4 线等同步串行接口。  

本库提供ch341 API的python绑定，底层API由WCH提供，详见[https://www.wch.cn/](https://www.wch.cn/)。

*注意（L）*
*解压安装后，ch341.py里的 class 名称为 Ch341。因为在引用的时候，正确写法是这样的`from ch341 import Ch341`，AI给的代码可能是这么写的`from ch341 import CH341`*

### 安装
1. 解压，然后放到项目的文件夹里（L）
2. 终端切换到项目文件夹，执行安装（L）
```
python setup.py install
```
Ps：安装的方法不止一种，可自行搜索（L）
### 版本依赖
- python 3.9+

### 开发进度

**功能**
- [x] i2c
- [x] spi
- [x] gpio
- [x] 中断回调

**例程**
- [x] mpu6050例程
- [ ] ssd1306例程
- [x] at24cXX例程

**平台支持**
- [x] Windows
- [ ] Linux


